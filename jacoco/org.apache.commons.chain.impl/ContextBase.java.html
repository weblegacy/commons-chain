<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ContextBase.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Commons Chain</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.chain.impl</a> &gt; <span class="el_source">ContextBase.java</span></div><h1>ContextBase.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.chain.impl;

import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.AbstractCollection;
import java.util.AbstractSet;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

import org.apache.commons.chain.Context;

/**
 * Convenience base class for {@link Context} implementations.
 *
 * &lt;p&gt;In addition to the minimal functionality required by the {@link Context}
 * interface, this class implements the recommended support for
 * &lt;em&gt;Attribute-Property Transparency&lt;/em&gt;. This is implemented by
 * analyzing the available JavaBeans properties of this class (or its
 * subclass), exposes them as key-value pairs in the {@code Map},
 * with the key being the name of the property itself.&lt;/p&gt;
 *
 * &lt;p&gt;&lt;strong&gt;IMPLEMENTATION NOTE&lt;/strong&gt; - Because {@code empty} is a
 * read-only property defined by the {@code Map} interface, it may not
 * be utilized as an attribute key or property name.&lt;/p&gt;
 *
 * @author Craig R. McClanahan
 * @version $Revision$ $Date$
 */
public class ContextBase extends HashMap&lt;String, Object&gt; implements Context {
    private static final long serialVersionUID = -2482145117370708259L;

    // ------------------------------------------------------ Static Variables

    /**
     * Distinguished singleton value that is stored in the map for each
     * key that is actually a property. This value is used to ensure that
     * {@code equals()} comparisons will always fail.
     */
<span class="fc" id="L62">    private static final Object SINGLETON = new Serializable() {</span>
        private static final long serialVersionUID = -6023767081282668587L;

        @Override
        public boolean equals(Object object) {
<span class="nc" id="L67">            return false;</span>
        }

        @Override
        public int hashCode() {
<span class="nc" id="L72">            return super.hashCode();</span>
        }
    };

    // ------------------------------------------------------ Instance Variables

    // NOTE - PropertyDescriptor instances are not Serializable, so the
    // following variables must be declared as transient. When a ContextBase
    // instance is deserialized, the no-arguments constructor is called,
    // and the initialize() method called there will repopulate them.
    // Therefore, no special restoration activity is required.

    /**
     * The {@code PropertyDescriptor}s for all JavaBeans properties
     * of this {@link Context} implementation class as an array.
     */
<span class="pc" id="L88">    private final transient PropertyDescriptor[] pds = getPropertyDescriptors();</span>

    /**
     * The {@code PropertyDescriptor}s for all JavaBeans properties
     * of this {@link Context} implementation class, keyed by property name.
     * This collection is allocated only if there are any JavaBeans
     * properties.
     */
<span class="pc" id="L96">    private final transient Map&lt;String, PropertyDescriptor&gt; descriptors = getMapDescriptors();</span>

    // ------------------------------------------------------------ Constructors

    /**
     * Default, no argument constructor.
     */
<span class="fc" id="L103">    public ContextBase() {</span>
<span class="fc" id="L104">    }</span>

    /**
     * Initialize the contents of this {@link Context} by copying the
     * values from the specified {@code Map}. Any keys in {@code map}
     * that correspond to local properties will cause the setter method for
     * that property to be called.
     *
     * @param map Map whose key-value pairs are added
     *
     * @throws IllegalArgumentException if an exception is thrown
     *         writing a local property value.
     * @throws UnsupportedOperationException if a local property does not
     *         have a write method.
     */
    public ContextBase(Map&lt;String, Object&gt; map) {
<span class="nc" id="L120">        super(map);</span>
<span class="nc" id="L121">        putAll(map);</span>
<span class="nc" id="L122">    }</span>

    // ------------------------------------------------------------- Map Methods

    /**
     * Override the default {@code Map} behavior to clear all keys and
     * values except those corresponding to JavaBeans properties.
     */
    @Override
    public void clear() {
<span class="fc bfc" id="L132" title="All 2 branches covered.">        if (descriptors == null) {</span>
<span class="fc" id="L133">            super.clear();</span>
        } else {
<span class="fc" id="L135">            Iterator&lt;String&gt; keys = keySet().iterator();</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">            while (keys.hasNext()) {</span>
<span class="fc" id="L137">                String key = keys.next();</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">                if (!descriptors.containsKey(key)) {</span>
<span class="fc" id="L139">                    keys.remove();</span>
                }
<span class="fc" id="L141">            }</span>
        }
<span class="fc" id="L143">    }</span>

    /**
     * Override the default {@code Map} behavior to return
     * {@code true} if the specified value is present in either the
     * underlying {@code Map} or one of the local property values.
     *
     * @param value the value look for in the context.
     *
     * @return {@code true} if found in this context otherwise
     *         {@code false}.
     *
     * @throws IllegalArgumentException if a property getter
     *         throws an exception
     */
    @Override
    public boolean containsValue(Object value) {
<span class="fc" id="L160">        boolean b = super.containsValue(value);</span>

        // Case 1 -- no local properties
<span class="fc bfc" id="L163" title="All 2 branches covered.">        if (descriptors == null) {</span>
<span class="fc" id="L164">            return b;</span>
        }

        // Case 2 -- value found in the underlying Map
<span class="fc bfc" id="L168" title="All 2 branches covered.">        if (b) {</span>
<span class="fc" id="L169">            return true;</span>
        }

        // Case 3 -- check the values of our readable properties
<span class="fc bfc" id="L173" title="All 2 branches covered.">        for (PropertyDescriptor pd : pds) {</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">            if (pd.getReadMethod() != null) {</span>
<span class="fc" id="L175">                Object prop = readProperty(pd);</span>
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">                if (value == null) {</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">                    if (prop == null) {</span>
<span class="nc" id="L178">                        return true;</span>
                    }
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">                } else if (value.equals(prop)) {</span>
<span class="nc" id="L181">                    return true;</span>
                }
            }
        }
<span class="fc" id="L185">        return false;</span>
    }

    /**
     * Override the default {@code Map} behavior to return a
     * {@code Set} that meets the specified default behavior except
     * for attempts to remove the key for a property of the {@link Context}
     * implementation class, which will throw
     * {@code UnsupportedOperationException}.
     *
     * @return Set of entries in the Context.
     */
    @Override
    public Set&lt;Map.Entry&lt;String, Object&gt;&gt; entrySet() {
<span class="fc" id="L199">        return new EntrySetImpl();</span>
    }

    /**
     * Override the default {@code Map} behavior to return the value
     * of a local property if the specified key matches a local property name.
     *
     * &lt;p&gt;&lt;strong&gt;IMPLEMENTATION NOTE&lt;/strong&gt; - If the specified
     * {@code key} identifies a write-only property, {@code null}
     * will arbitrarily be returned, in order to avoid difficulties implementing
     * the contracts of the {@code Map} interface.&lt;/p&gt;
     *
     * @param key Key of the value to be returned
     *
     * @return The value for the specified key.
     *
     * @throws IllegalArgumentException if an exception is thrown
     *         reading this local property value.
     * @throws UnsupportedOperationException if this local property does not
     *         have a read method.
     */
    @Override
    public Object get(Object key) {
        // Case 1 -- no local properties
<span class="fc bfc" id="L223" title="All 2 branches covered.">        if (descriptors == null) {</span>
<span class="fc" id="L224">            return super.get(key);</span>
        }

        // Case 2 -- this is a local property
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">        if (key != null) {</span>
<span class="fc" id="L229">            final PropertyDescriptor descriptor = descriptors.get(key);</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">            if (descriptor != null) {</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">                if (descriptor.getReadMethod() != null) {</span>
<span class="fc" id="L232">                    return readProperty(descriptor);</span>
                } else {
<span class="fc" id="L234">                    return null;</span>
                }
            }
        }

        // Case 3 -- retrieve value from our underlying Map
<span class="fc" id="L240">        return super.get(key);</span>
    }

    /**
     * Override the default {@code Map} behavior to return
     * {@code true} if the underlying {@code Map} only contains
     * key-value pairs for local properties (if any).
     *
     * @return {@code true} if this Context is empty, otherwise
     *         {@code false}.
     */
    @Override
    public boolean isEmpty() {
        // Case 1 -- no local properties
<span class="fc bfc" id="L254" title="All 2 branches covered.">        if (descriptors == null) {</span>
<span class="fc" id="L255">            return super.isEmpty();</span>
        }

        // Case 2 -- compare key count to property count
<span class="fc bfc" id="L259" title="All 2 branches covered.">        return super.size() &lt;= descriptors.size();</span>
    }

    /**
     * Override the default {@code Map} behavior to return a
     * {@code Set} that meets the specified default behavior except
     * for attempts to remove the key for a property of the {@link Context}
     * implementation class, which will throw
     * {@code UnsupportedOperationException}.
     *
     * @return The set of keys for objects in this Context.
     */
    public Set&lt;String&gt; keySet() {
<span class="fc" id="L272">        return super.keySet();</span>
    }

    /**
     * Override the default {@code Map} behavior to set the value of a
     * local property if the specified key matches a local property name.
     *
     * @param key Key of the value to be stored or replaced
     * @param value New value to be stored
     *
     * @return The value added to the Context.
     *
     * @throws IllegalArgumentException if an exception is thrown
     *         reading or writing this local property value.
     * @throws UnsupportedOperationException if this local property does not
     *         have both a read method and a write method
     */
    @Override
    public Object put(String key, Object value) {
        // Case 1 -- no local properties
<span class="fc bfc" id="L292" title="All 2 branches covered.">        if (descriptors == null) {</span>
<span class="fc" id="L293">            return super.put(key, value);</span>
        }

        // Case 2 -- this is a local property
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">        if (key != null) {</span>
<span class="fc" id="L298">            final PropertyDescriptor descriptor = descriptors.get(key);</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">            if (descriptor != null) {</span>
<span class="fc" id="L300">                Object previous = null;</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">                if (descriptor.getReadMethod() != null) {</span>
<span class="fc" id="L302">                    previous = readProperty(descriptor);</span>
                }
<span class="fc" id="L304">                writeProperty(descriptor, value);</span>
<span class="fc" id="L305">                return previous;</span>
            }
        }

        // Case 3 -- store or replace value in our underlying map
<span class="fc" id="L310">        return super.put(key, value);</span>
    }

    /**
     * Override the default {@code Map} behavior to call the
     * {@code put()} method individually for each key-value pair
     * in the specified {@code Map}.
     *
     * @param map {@code Map} containing key-value pairs to store
     *        (or replace)
     *
     * @throws IllegalArgumentException if an exception is thrown
     *         reading or writing a local property value.
     * @throws UnsupportedOperationException if a local property does not
     *         have both a read method and a write method
     */
    @Override
    public void putAll(Map&lt;? extends String, ? extends Object&gt; map) {
<span class="fc" id="L328">        map.forEach(this::put);</span>
<span class="fc" id="L329">    }</span>

    /**
     * Override the default {@code Map} behavior to throw
     * {@code UnsupportedOperationException} on any attempt to
     * remove a key that is the name of a local property.
     *
     * @param key Key to be removed
     *
     * @return The value removed from the Context.
     *
     * @throws UnsupportedOperationException if the specified
     *         {@code key} matches the name of a local property
     */
    @Override
    public Object remove(Object key) {
        // Case 1 -- no local properties
<span class="fc bfc" id="L346" title="All 2 branches covered.">        if (descriptors == null) {</span>
<span class="fc" id="L347">            return super.remove(key);</span>
        }

        // Case 2 -- this is a local property
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">        if (key != null) {</span>
<span class="fc" id="L352">            PropertyDescriptor descriptor = descriptors.get(key);</span>
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">            if (descriptor != null) {</span>
<span class="nc" id="L354">                throw new UnsupportedOperationException(&quot;Local property '&quot; + key + &quot;' cannot be removed&quot;);</span>
            }
        }

        // Case 3 -- remove from underlying Map
<span class="fc" id="L359">        return super.remove(key);</span>
    }

    /**
     * Override the default {@code Map} behavior to return a
     * {@code Collection} that meets the specified default behavior except
     * for attempts to remove the key for a property of the {@link Context}
     * implementation class, which will throw
     * {@code UnsupportedOperationException}.
     *
     * @return The collection of values in this Context.
     */
    @Override
    public Collection&lt;Object&gt; values() {
<span class="nc" id="L373">        return new ValuesImpl();</span>
    }

    // --------------------------------------------------------- Private Methods

    /**
     * Return an {@code Iterator} over the set of {@code Map.Entry}
     * objects representing our key-value pairs.
     *
     * @return an {@code Iterator} over the set of {@code Map.Entry} objects
     */
    private Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; entriesIterator() {
<span class="fc" id="L385">        return new EntrySetIterator();</span>
    }

    /**
     * Return a {@code Map.Entry} for the specified key value, if it
     * is present; otherwise, return {@code null}.
     *
     * @param key Attribute key or property name
     *
     * @return a {@code Map.Entry} for the specified key value, if it
     *         is present; otherwise, return {@code null}
     */
    private Map.Entry&lt;String, Object&gt; entry(Object key) {
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">        if (containsKey(key)) {</span>
<span class="fc" id="L399">            return new MapEntryImpl(key.toString(), get(key));</span>
        } else {
<span class="nc" id="L401">            return null;</span>
        }
    }

    /**
     * Get and return the value for the specified property.
     *
     * @param descriptor {@code PropertyDescriptor} for the
     *        specified property
     *
     * @return the value of the specified property
     *
     * @throws IllegalArgumentException if an exception is thrown
     *         reading this local property value.
     * @throws UnsupportedOperationException if this local property does not
     *         have a read method.
     */
    private Object readProperty(PropertyDescriptor descriptor) {
        try {
<span class="fc" id="L420">            Method method = descriptor.getReadMethod();</span>
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">            if (method == null) {</span>
<span class="nc" id="L422">                throw new UnsupportedOperationException(&quot;Property '&quot;</span>
<span class="nc" id="L423">                     + descriptor.getName() + &quot;' is not readable&quot;);</span>
            }
<span class="fc" id="L425">            return method.invoke(this);</span>
<span class="nc" id="L426">        } catch (Exception e) {</span>
<span class="nc" id="L427">            throw new UnsupportedOperationException(&quot;Exception reading property '&quot;</span>
<span class="nc" id="L428">                 + descriptor.getName() + &quot;': &quot; + e.getMessage());</span>
        }
    }

    /**
     * Remove the specified key-value pair, if it exists, and return
     * {@code true}. If this pair does not exist, return {@code false}.
     *
     * @param entry Key-value pair to be removed
     *
     * @return if the specified key-value pair is removed, return
     *         {@code true}, otherwise {@code false}
     *
     * @throws UnsupportedOperationException if the specified key
     *         identifies a property instead of an attribute.
     */
    private boolean remove(Map.Entry&lt;?, ?&gt; entry) {
<span class="nc" id="L445">        Map.Entry&lt;String, Object&gt; actual = entry(entry.getKey());</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">        if (actual == null) {</span>
<span class="nc" id="L447">            return false;</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">        } else if (entry.equals(actual)) {</span>
<span class="nc" id="L449">            remove(entry.getKey());</span>
<span class="nc" id="L450">            return true;</span>
        } else {
<span class="nc" id="L452">            return false;</span>
        }
    }

    /**
     * Return an {@code Iterator} over the set of values in this
     * {@code Map}.
     *
     * @return an {@code Iterator} over the set of values in this
     *         {@code Map}
     */
    private Iterator&lt;Object&gt; valuesIterator() {
<span class="nc" id="L464">        return new ValuesIterator();</span>
    }

    /**
     * Set the value for the specified property.
     *
     * @param descriptor {@code PropertyDescriptor} for the
     *        specified property
     * @param value The new value for this property (must be of the
     *        correct type)
     *
     * @throws IllegalArgumentException if an exception is thrown
     *         writing this local property value.
     * @throws UnsupportedOperationException if this local property does not
     *         have a write method.
     */
    private void writeProperty(PropertyDescriptor descriptor, Object value) {
        try {
<span class="fc" id="L482">            Method method = descriptor.getWriteMethod();</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">            if (method == null) {</span>
<span class="fc" id="L484">                throw new UnsupportedOperationException(&quot;Property '&quot; + descriptor.getName()</span>
                     + &quot;' is not writeable&quot;);
            }
<span class="fc" id="L487">            method.invoke(this, value);</span>
<span class="fc" id="L488">        } catch (Exception e) {</span>
<span class="fc" id="L489">            throw new UnsupportedOperationException(&quot;Exception writing property '&quot;</span>
<span class="fc" id="L490">                 + descriptor.getName() + &quot;': &quot; + e.getMessage());</span>
<span class="fc" id="L491">        }</span>
<span class="fc" id="L492">    }</span>

    /**
     * Returns descriptors for all properties of the bean.
     *
     * @return descriptors for all properties of the bean
     *         or an empty array if an problem occurs
     */
    private PropertyDescriptor[] getPropertyDescriptors() {
        // Retrieve the set of property descriptors for this Context class
        try {
<span class="fc" id="L503">            return Introspector.getBeanInfo(getClass()).getPropertyDescriptors();</span>
<span class="nc" id="L504">        } catch (IntrospectionException e) {</span>
<span class="nc" id="L505">            return new PropertyDescriptor[0]; // Should never happen</span>
        }
    }

    /**
     * The {@code PropertyDescriptor}s for all JavaBeans properties
     * of this {@link Context} implementation class, keyed by property
     * name. This collection is allocated only if there are any JavaBeans
     * properties.
     *
     * @return {@code PropertyDescriptor}s for all JavaBeans properties
     *         as an collection or {@code null} if there are no JavaBeans
     *         properties
     */
    private Map&lt;String, PropertyDescriptor&gt; getMapDescriptors() {
<span class="fc" id="L520">        Map&lt;String, PropertyDescriptor&gt; ret = new HashMap&lt;&gt;();</span>

        // Initialize the underlying Map contents
<span class="fc bfc" id="L523" title="All 2 branches covered.">        for (PropertyDescriptor pd : pds) {</span>
<span class="fc" id="L524">            String name = pd.getName();</span>

            // Add descriptor (ignoring getClass() and isEmpty())
<span class="fc bfc" id="L527" title="All 4 branches covered.">            if (!(&quot;class&quot;.equals(name) || &quot;empty&quot;.equals(name))) {</span>
<span class="fc" id="L528">                ret.put(name, pd);</span>
<span class="fc" id="L529">                super.put(name, SINGLETON);</span>
            }
        }

<span class="fc bfc" id="L533" title="All 2 branches covered.">        return ret.isEmpty() ? null : ret;</span>
    }

    // --------------------------------------------------------- Private Classes

    /**
     * Private implementation of {@code Set} that implements the
     * semantics required for the value returned by {@code entrySet()}.
     */
<span class="fc" id="L542">    private class EntrySetImpl extends AbstractSet&lt;Map.Entry&lt;String, Object&gt;&gt; {</span>

        @Override
        public void clear() {
<span class="nc" id="L546">            ContextBase.this.clear();</span>
<span class="nc" id="L547">        }</span>

        @Override
        public boolean contains(Object obj) {
<span class="nc bnc" id="L551" title="All 2 branches missed.">            if (!(obj instanceof Map.Entry)) {</span>
<span class="nc" id="L552">                return false;</span>
            }
<span class="nc" id="L554">            Map.Entry&lt;?, ?&gt; entry = (Map.Entry&lt;?, ?&gt;) obj;</span>
<span class="nc" id="L555">            Map.Entry&lt;String, Object&gt; actual = ContextBase.this.entry(entry.getKey());</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">            if (actual != null) {</span>
<span class="nc" id="L557">                return actual.equals(entry);</span>
            } else {
<span class="nc" id="L559">                return false;</span>
            }
        }

        @Override
        public boolean isEmpty() {
<span class="nc" id="L565">            return ContextBase.this.isEmpty();</span>
        }

        @Override
        public Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; iterator() {
<span class="fc" id="L570">            return ContextBase.this.entriesIterator();</span>
        }

        @Override
        public boolean remove(Object obj) {
<span class="nc bnc" id="L575" title="All 2 branches missed.">            if (obj instanceof Map.Entry) {</span>
<span class="nc" id="L576">                return ContextBase.this.remove((Map.Entry&lt;?, ?&gt;) obj);</span>
            } else {
<span class="nc" id="L578">                return false;</span>
            }
        }

        @Override
        public int size() {
<span class="nc" id="L584">            return ContextBase.this.size();</span>
        }
    }

    /**
     * Private implementation of {@code Iterator} for the
     * {@code Set} returned by {@code entrySet()}.
     */
<span class="fc" id="L592">    private class EntrySetIterator implements Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; {</span>

<span class="fc" id="L594">        private Map.Entry&lt;String, Object&gt; entry = null;</span>
<span class="fc" id="L595">        private Iterator&lt;String&gt; keys = ContextBase.this.keySet().iterator();</span>

        @Override
        public boolean hasNext() {
<span class="fc" id="L599">            return keys.hasNext();</span>
        }

        @Override
        public Map.Entry&lt;String, Object&gt; next() {
<span class="fc" id="L604">            entry = ContextBase.this.entry(keys.next());</span>
<span class="fc" id="L605">            return entry;</span>
        }

        @Override
        public void remove() {
<span class="nc" id="L610">            ContextBase.this.remove(entry);</span>
<span class="nc" id="L611">        }</span>
    }

    /**
     * Private implementation of {@code Map.Entry} for each item in
     * {@code EntrySetImpl}.
     */
    private class MapEntryImpl implements Map.Entry&lt;String, Object&gt; {

        private String key;
        private Object value;

<span class="fc" id="L623">        MapEntryImpl(String key, Object value) {</span>
<span class="fc" id="L624">            this.key = key;</span>
<span class="fc" id="L625">            this.value = value;</span>
<span class="fc" id="L626">        }</span>

        @Override
        public boolean equals(Object obj) {
<span class="nc bnc" id="L630" title="All 2 branches missed.">            if (this == obj) {</span>
<span class="nc" id="L631">                return true;</span>
            }
<span class="nc bnc" id="L633" title="All 4 branches missed.">            if (obj == null || getClass() != obj.getClass()) {</span>
<span class="nc" id="L634">                return false;</span>
            }
<span class="nc" id="L636">            MapEntryImpl other = (MapEntryImpl) obj;</span>
<span class="nc bnc" id="L637" title="All 2 branches missed.">            if (!getEnclosingInstance().equals(other.getEnclosingInstance())) {</span>
<span class="nc" id="L638">                return false;</span>
            }
<span class="nc bnc" id="L640" title="All 4 branches missed.">            return Objects.equals(key, other.key) &amp;&amp; Objects.equals(value, other.value);</span>
        }

        @Override
        public String getKey() {
<span class="fc" id="L645">            return this.key;</span>
        }

        @Override
        public Object getValue() {
<span class="fc" id="L650">            return this.value;</span>
        }

        @Override
        public int hashCode() {
<span class="fc" id="L655">            return Objects.hashCode(key) ^ Objects.hashCode(value);</span>
        }

        @Override
        public Object setValue(Object value) {
<span class="nc" id="L660">            Object previous = this.value;</span>
<span class="nc" id="L661">            ContextBase.this.put(this.key, value);</span>
<span class="nc" id="L662">            this.value = value;</span>
<span class="nc" id="L663">            return previous;</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L668">            return getKey() + &quot;=&quot; + getValue();</span>
        }

        private ContextBase getEnclosingInstance() {
<span class="nc" id="L672">            return ContextBase.this;</span>
        }
    }

    /**
     * Private implementation of {@code Collection} that implements the
     * semantics required for the value returned by {@code values()}.
     */
<span class="nc" id="L680">    private class ValuesImpl extends AbstractCollection&lt;Object&gt; {</span>

        @Override
        public void clear() {
<span class="nc" id="L684">            ContextBase.this.clear();</span>
<span class="nc" id="L685">        }</span>

        @Override
        public boolean contains(Object obj) {
<span class="nc bnc" id="L689" title="All 2 branches missed.">            if (!(obj instanceof Map.Entry)) {</span>
<span class="nc" id="L690">                return false;</span>
            }
<span class="nc" id="L692">            Map.Entry&lt;?, ?&gt; entry = (Map.Entry&lt;?, ?&gt;) obj;</span>
<span class="nc" id="L693">            return ContextBase.this.containsValue(entry.getValue());</span>
        }

        @Override
        public boolean isEmpty() {
<span class="nc" id="L698">            return ContextBase.this.isEmpty();</span>
        }

        @Override
        public Iterator&lt;Object&gt; iterator() {
<span class="nc" id="L703">            return ContextBase.this.valuesIterator();</span>
        }

        @Override
        public boolean remove(Object obj) {
<span class="nc bnc" id="L708" title="All 2 branches missed.">            if (obj instanceof Map.Entry) {</span>
<span class="nc" id="L709">                return ContextBase.this.remove((Map.Entry&lt;?, ?&gt;) obj);</span>
            } else {
<span class="nc" id="L711">                return false;</span>
            }
        }

        @Override
        public int size() {
<span class="nc" id="L717">            return ContextBase.this.size();</span>
        }
    }

    /**
     * Private implementation of {@code Iterator} for the
     * {@code Collection} returned by {@code values()}.
     */
<span class="nc" id="L725">    private class ValuesIterator implements Iterator&lt;Object&gt; {</span>

<span class="nc" id="L727">        private Map.Entry&lt;String, Object&gt; entry = null;</span>
<span class="nc" id="L728">        private Iterator&lt;String&gt; keys = ContextBase.this.keySet().iterator();</span>

        @Override
        public boolean hasNext() {
<span class="nc" id="L732">            return keys.hasNext();</span>
        }

        @Override
        public Object next() {
<span class="nc" id="L737">            entry = ContextBase.this.entry(keys.next());</span>
<span class="nc" id="L738">            return entry.getValue();</span>
        }

        @Override
        public void remove() {
<span class="nc" id="L743">            ContextBase.this.remove(entry);</span>
<span class="nc" id="L744">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>