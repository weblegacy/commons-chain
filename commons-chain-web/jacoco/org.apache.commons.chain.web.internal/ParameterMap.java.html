<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ParameterMap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Commons Chain :: Web</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.chain.web.internal</a> &gt; <span class="el_source">ParameterMap.java</span></div><h1>ParameterMap.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.chain.web.internal;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.function.Function;
import java.util.function.Supplier;

import org.apache.commons.chain.web.MapEntry;

/**
 * Implementation of {@code Map} for immutable parameters with a
 * parameter-provider.
 *
 * @param &lt;P&gt; the type of the parameter-provider
 * @param &lt;T&gt; the type of results supplied by this parameters
 *
 * @author Graff Stefan
 * @since Chain 1.3
 */
public class ParameterMap&lt;P, T&gt; implements Map&lt;String, T&gt; {

    /**
     * The parameter-provider.
     */
    private final P parameter;

    /**
     * Function to return the value of a parameter as an
     * {@link String}, or {@code null} if no parameter of the
     * given name exists.
     */
    private final Function&lt;String, T&gt; valueFunction;

    /**
     * Supplier to return an {@link Enumeration} of {@link String}
     * objects containing the names of the parameters contained
     * in this object.
     */
    private final Supplier&lt;Enumeration&lt;String&gt;&gt; namesSupplier;

    /**
     * The constructor for an immutable parameter-map.
     *
     * @param parameter the parameter-provider
     * @param valueFunction Function to return the value of a parameter
     * @param namesSupplier Supplier to return all names of the parameter
     */
    public ParameterMap(final P parameter, final Function&lt;String, T&gt; valueFunction,
<span class="fc" id="L72">            final Supplier&lt;Enumeration&lt;String&gt;&gt; namesSupplier) {</span>

<span class="fc" id="L74">        this.parameter = parameter;</span>
<span class="fc" id="L75">        this.valueFunction = valueFunction;</span>
<span class="fc" id="L76">        this.namesSupplier = namesSupplier;</span>
<span class="fc" id="L77">    }</span>

    /**
     * Removes all of the mappings from this parameter-map.
     * The parameter-map will be empty after this call returns.
     *
     * @throws UnsupportedOperationException because it is an
     *         immutable parameter-map
     */
    @Override
    public void clear() {
<span class="fc" id="L88">        throw new UnsupportedOperationException();</span>
    }

    /**
     * Returns {@code true} if this parameter-map contains a mapping
     * for the specified key.
     *
     * @param key The key whose presence in this parameter-map is to
     *            be tested
     *
     * @return {@code true} if this parameter-map contains a mapping
     *         for the specified key.
     */
    @Override
    public boolean containsKey(Object key) {
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">        return valueFunction.apply(key(key)) != null;</span>
    }

    /**
     * Returns {@code true} if this parameter-map maps one or more keys
     * to the specified value.
     *
     * @param value value whose presence in this parameter-map is to be
     *        tested
     *
     * @return {@code true} if this parameter-map maps one or more keys
     *         to the specified value
     */
    @Override
    public boolean containsValue(Object value) {
<span class="fc" id="L118">        final Enumeration&lt;String&gt; keys = namesSupplier.get();</span>
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">        while (keys.hasMoreElements()) {</span>
<span class="fc" id="L120">            final T next = valueFunction.apply(keys.nextElement());</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">            if (value.equals(next)) {</span>
<span class="fc" id="L122">                return true;</span>
            }
<span class="fc" id="L124">        }</span>
<span class="nc" id="L125">        return false;</span>
    }

    /**
     * Returns a {@link Set} view of the mappings contained in this
     * parameter-map. The set is not backed by the parameter-map, so
     * changes to the parameter-map are not reflected in the set,
     * and vice-versa.
     *
     * @return a set view of the mappings contained in this
     *         parameter-map
     */
    @Override
    public Set&lt;Map.Entry&lt;String, T&gt;&gt; entrySet() {
<span class="fc" id="L139">        return entrySet(false);</span>
    }

    /**
     * Returns the value to which the specified key is mapped,
     * or {@code null} if this parameter-map contains no mapping
     * for the key.
     *
     * &lt;p&gt;A return value of {@code null} does not &lt;i&gt;necessarily&lt;/i&gt;
     * indicate that the parameter-map contains no mapping for the key;
     * it's also possible that the parameter-map explicitly maps the key
     * to {@code null}. The {@link #containsKey containsKey} operation
     * may be used to distinguish these two cases.&lt;/p&gt;
     *
     * @param key the key whose associated value is to be returned
     *
     * @return the value to which the specified key is mapped, or
     *         {@code null} if this parameter-map contains no mapping for
     *         the key
     *
     * @see #put(Object, Object)
     */
    @Override
    public T get(Object key) {
<span class="fc" id="L163">        return valueFunction.apply(key(key));</span>
    }

    /**
     * Returns {@code true} if this parameter-map contains no
     * key-value mappings.
     *
     * @return {@code true} if this parameter-map contains no
     *         key-value mappings
     */
    @Override
    public boolean isEmpty() {
<span class="nc bnc" id="L175" title="All 2 branches missed.">        return !namesSupplier.get().hasMoreElements();</span>
    }

    /**
     * Returns a {@link Set} view of the keys contained in this
     * parameter-map. The set is not backed by the parameter-map, so
     * changes to the parameter-map are not reflected in the set, and
     * vice-versa.
     *
     * @return a set view of the keys contained in this parameter-map
     */
    @Override
    public Set&lt;String&gt; keySet() {
<span class="fc" id="L188">        final Set&lt;String&gt; set = new HashSet&lt;&gt;();</span>
<span class="fc" id="L189">        final Enumeration&lt;String&gt; keys = namesSupplier.get();</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">        while (keys.hasMoreElements()) {</span>
<span class="fc" id="L191">            set.add(keys.nextElement());</span>
        }
<span class="fc" id="L193">        return set;</span>
    }

    /**
     * Associates the specified value with the specified key in this
     * parameter-map. If the parameter-map previously contained a
     * mapping for the key, the old value is replaced.
     *
     * @param key key with which the specified value is to be associated
     * @param value value to be associated with the specified key
     *
     * @return the previous value associated with {@code key}, or
     *         {@code null} if there was no mapping for {@code key}.
     *         (A {@code null} return can also indicate that the
     *         parameter-map previously associated {@code null} with
     *         {@code key.)
     *
     * @throws UnsupportedOperationException because it is an
     *         immutable parameter-map
     */
    @Override
    public T put(String key, T value) {
<span class="fc" id="L215">        throw new UnsupportedOperationException();</span>
    }

    /**
     * Copies all of the mappings from the specified map to this
     * parameter-map. These mappings will replace any mappings that
     * this parameter-map had for any of the keys currently in the
     * specified map.
     *
     * @param map mappings to be stored in this parameter-map
     *
     * @throws NullPointerException if the specified map is null
     * @throws UnsupportedOperationException because it is an
     *         immutable parameter-map
     */
    @Override
    public void putAll(Map&lt;? extends String, ? extends T&gt; map) {
<span class="fc" id="L232">        throw new UnsupportedOperationException();</span>
    }

    /**
     * Removes the mapping for the specified key from this
     * parameter-map if present.
     *
     * @param key key whose mapping is to be removed from the
     *        parameter-map
     *
     * @return the previous value associated with {@code key}, or
     *         {@code null} if there was no mapping for {@code key}.
     *         (A {@code null} return can also indicate that the
     *         parameter-map previously associated {@code null} with
     *         {@code key.)
     *
     * @throws UnsupportedOperationException because it is an
     *         immutable parameter-map
     */
    @Override
    public T remove(Object key) {
<span class="fc" id="L253">        throw new UnsupportedOperationException();</span>
    }

    /**
     * Returns the number of key-value mappings in this parameter-map.
     *
     * @return the number of key-value mappings in this parameter-map
     */
    @Override
    public int size() {
<span class="fc" id="L263">        int n = 0;</span>
<span class="fc" id="L264">        final Enumeration&lt;String&gt; keys = namesSupplier.get();</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">        while (keys.hasMoreElements()) {</span>
<span class="fc" id="L266">            keys.nextElement();</span>
<span class="fc" id="L267">            n++;</span>
        }
<span class="fc" id="L269">        return n;</span>
    }

    /**
     * Returns a {@link Collection} view of the values contained in
     * this parameter-map. The collection is not backed by the
     * parameter-map, so changes to the parameter-map are not
     * reflected in the collection, and vice-versa.
     *
     * @return a view of the values contained in this parameter-map
     */
    @Override
    public Collection&lt;T&gt; values() {
<span class="fc" id="L282">        final List&lt;T&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L283">        final Enumeration&lt;String&gt; keys = namesSupplier.get();</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">        while (keys.hasMoreElements()) {</span>
<span class="fc" id="L285">            list.add(valueFunction.apply(keys.nextElement()));</span>
        }
<span class="fc" id="L287">        return list;</span>
    }

    /**
     * Returns the hash code value for this parameter-map. The
     * hash code of a parameter-map is defined to be the sum of
     * the hash codes of each entry in the parameter-map's
     * {@code entrySet()} view. This ensures that {@code m1.equals(m2)}
     * implies that {@code m1.hashCode()==m2.hashCode()} for any two
     * parameter-maps {@code m1} and {@code m2}, as required by the
     * general contract of {@link Object#hashCode}.
     *
     * @implSpec
     * This implementation calls the {@code hashCode()} from the
     * parameter-provider.
     *
     * @return the hash code value for this parameter-map
     */
    @Override
    public int hashCode() {
<span class="fc" id="L307">        return getParameter().hashCode();</span>
    }

    /**
     * Compares the specified object with this parameter-map for equality.
     * Returns {@code true} if the given object is also a parameter-map
     * and the two parameter-maps represent the same mappings. More formally,
     * two parameter-maps {@code m1} and {@code m2} represent the same
     * mappings if {@code m1.entrySet().equals(m2.entrySet())}.
     *
     * @implSpec
     * This implementation first checks if the specified object is this
     * parameter-map; if so it returns {@code true}. Then, it checks if
     * the specified object is the identical class this parameter-map; if
     * not, it returns {@code false}. If so, it calls the {@code equals()}
     * from the parameter-provider and returns its return-code.
     *
     * @param obj object to be compared for equality with this
     *        parameter-map
     *
     * @return {@code true} if the specified object is equal to this
     *         parameter-map
     */
    @Override
    public boolean equals(Object obj) {
<span class="nc bnc" id="L332" title="All 2 branches missed.">        if (this == obj) {</span>
<span class="nc" id="L333">            return true;</span>
        }
<span class="nc bnc" id="L335" title="All 4 branches missed.">        if (obj == null || getClass() != obj.getClass()) {</span>
<span class="nc" id="L336">            return false;</span>
        }
<span class="nc" id="L338">        final ParameterMap&lt;?, ?&gt; other = (ParameterMap&lt;?, ?&gt;) obj;</span>
<span class="nc" id="L339">        return Objects.equals(getParameter(), other.getParameter());</span>
    }

    /**
     * Returns a string representation of this parameter-map.
     * The string representation consists of a list of key-value
     * mappings in the order returned by the parameter-map's
     * {@code entrySet} view's iterator, enclosed in braces
     * ({@code &quot;{}&quot;}). Adjacent mappings are separated by the
     * characters {@code &quot;, &quot;} (comma and space). Each key-value
     * mapping is rendered as the key followed by an equals sign
     * ({@code &quot;=&quot;}) followed by the associated value. Keys and
     * values are converted to strings as by
     * {@link String#valueOf(Object)}.
     *
     * @return a string representation of this parameter-map
     */
    public String toString() {
<span class="nc" id="L357">        final Iterator&lt;Entry&lt;String, T&gt;&gt; entries = entrySet().iterator();</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">        if (entries.hasNext()) {</span>
<span class="nc" id="L359">            return &quot;{}&quot;;</span>
        }

<span class="nc" id="L362">        final StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L363">        sb.append('{');</span>
        for (;;) {
<span class="nc" id="L365">            final Entry&lt;String, T&gt; entrie = entries.next();</span>
<span class="nc" id="L366">            final String key = entrie.getKey();</span>
<span class="nc" id="L367">            final T value = entrie.getValue();</span>
<span class="nc" id="L368">            sb</span>
<span class="nc" id="L369">                .append(key)</span>
<span class="nc" id="L370">                .append('=')</span>
<span class="nc" id="L371">                .append(value);</span>

<span class="nc bnc" id="L373" title="All 2 branches missed.">            if (entries.hasNext()) {</span>
<span class="nc" id="L374">                sb.append(',').append(' ');</span>
            } else {
<span class="nc" id="L376">                return sb.append('}').toString();</span>
            }
<span class="nc" id="L378">        }</span>
    }

    /**
     * Returns the parameter-class.
     *
     * @return the parameter-class
     */
    protected P getParameter() {
<span class="fc" id="L387">        return parameter;</span>
    }

    /**
     * Returns the Function to return the value of a parameter as an
     * {@link String}, or {@code null} if no parameter of the given
     * name exists.
     *
     * @return the Function to return the value
     */
    protected  Function&lt;String, T&gt; getValueFunction() {
<span class="fc" id="L398">        return valueFunction;</span>
    }

    /**
     * Returns the Supplier to return an {@link Enumeration} of
     * {@link String} objects containing the names of the parameters
     * contained in this object.
     *
     * @return Supplier to return an {@link Enumeration} with all
     *         names of the parameters
     */
    protected Supplier&lt;Enumeration&lt;String&gt;&gt; getNamesSupplier() {
<span class="fc" id="L410">        return namesSupplier;</span>
    }

    /**
     * Returns a {@link Set} view of the mappings contained
     * in this map.
     *
     * @param modifiable Whether the entries should allow
     *                   modification or not
     *
     * @return a set view of the mappings contained in this map
     */
    protected Set&lt;Map.Entry&lt;String, T&gt;&gt; entrySet(boolean modifiable) {
<span class="fc" id="L423">        final Set&lt;Map.Entry&lt;String, T&gt;&gt; set = new HashSet&lt;&gt;();</span>
<span class="fc" id="L424">        final Enumeration&lt;String&gt; keys = namesSupplier.get();</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">        while (keys.hasMoreElements()) {</span>
<span class="fc" id="L426">            final String key = keys.nextElement();</span>
<span class="fc" id="L427">            set.add(new MapEntry&lt;&gt;(key, valueFunction.apply(key), modifiable));</span>
<span class="fc" id="L428">        }</span>
<span class="fc" id="L429">        return set;</span>
    }

    /**
     * Converts the {@code key} to a {@link String}.
     *
     * @param key the key
     *
     * @return the key as {@link String}
     */
    protected static String key(Object key) {
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">        if (key == null) {</span>
<span class="nc" id="L441">            throw new IllegalArgumentException();</span>
<span class="pc bpc" id="L442" title="1 of 2 branches missed.">        } else if (key instanceof String) {</span>
<span class="fc" id="L443">            return (String) key;</span>
        } else {
<span class="nc" id="L445">            return key.toString();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>